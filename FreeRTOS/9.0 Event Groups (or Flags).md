# Event Bits (or *flags*) and Event Groups

Gli **Event Bits** vengono utilizzati per indicare se un evento si è verificato o meno.Gli  **Event Bits** sono spesso indicati come *flag di* evento . Ad esempio, un'applicazione può:

* Definire un bit (o flag) che significa "Un messaggio è stato ricevuto ed è  pronto per l'elaborazione" quando è impostato su 1 e "non ci sono  messaggi in attesa di essere elaborato" quando è impostato su 0.
* Definire un bit (o flag) che significa "L'applicazione ha messo in coda un  messaggio pronto per essere inviato a una rete" quando è impostato su 1 e "non ci sono messaggi in coda pronti per essere inviati alla rete"  quando è è impostato su 0. 	
* Definisci un bit (o flag) che significa "È ora di inviare un messaggio heartbeat a una rete" quando è impostato su 1 e "non è ancora il momento di inviare un altro messaggio heartbeat" quando è impostato su 0. 

Gli **Event Groups** è un insieme di bit di eventi. I singoli bit di evento all'interno di un gruppo di eventi sono referenziati da un numero di bit. Espansione dell'esempio fornito sopra:

* Il bit di evento che significa "Un messaggio è stato ricevuto ed è pronto  per l'elaborazione" potrebbe essere il bit numero 0 all'interno di un  gruppo di eventi. 	
* Il bit di evento che significa "L'applicazione ha messo in coda un  messaggio che è pronto per essere inviato a una rete" potrebbe essere il bit numero 1 all'interno dello stesso gruppo di eventi. 	
* Il bit di evento che significa "È ora di inviare un messaggio heartbeat a  una rete" potrebbe essere il bit numero 2 all'interno dello stesso  gruppo di eventi. 

### Event Group and Event Bits Data Types

I gruppi di eventi sono referenziati da variabili di tipo *EventGroupHandle_t.*

Il numero di bit (o flag) memorizzati all'interno di un gruppo di eventi è 8 se **configUSE_16_BIT_TICKS**  è impostato su 1, o 24 se **configUSE_16_BIT_TICKS** è impostato su 0. La  dipendenza da configUSE_16_BIT_TICKS risulta dal tipo di dati utilizzato per l'archiviazione locale del thread nell'implementazione interna di  compiti.

Tutti i bit di evento in un gruppo di eventi vengono memorizzati in una singola variabile senza segno di tipo EventBits_t. Il bit di evento 0 viene memorizzato nella posizione di bit 0, il bit di  evento 1 viene memorizzato nella posizione di bit 1 e così via.

L'immagine seguente rappresenta un gruppo di eventi a 24 bit che utilizza tre bit  per contenere i tre eventi di esempio già descritti. Nell'immagine è impostato solo il bit 2 dell'evento.

![](https://www.freertos.org/fr-content-src/uploads/2018/07/24-bit-event-group.gif)

## Event Group RTOS API Functions

Vengono fornite funzioni API per gli events group che consentono a una task, tra le altre cose, di impostare uno o più events bit all'interno di un events group, cancellare uno o più bit di evento all'interno di un events group e pend (entrare nello stato Blocked in modo che la task non consumi tempo di elaborazione) per attendere che una serie di uno o più event bits venga impostata all'interno di un events group.

Gli event groups possono essere utilizzati anche per sincronizzare le varie task, creando ciò che viene spesso definito "rendezvous" della tasl. Un punto di sincronizzazione di una task è una posizione nel codice  dell'applicazione in cui una task  attenderà nello stato Blocked  (senza consumare tempo della CPU) fino a quando tutte le altre task che partecipano alla sincronizzazione raggiungeranno anche il loro punto di sincronizzazione.

### The Challenges an RTOS Must Overcome When Implementing Event Groups 

Le due principali sfide che un RTOS deve superare durante l'implementazione degli events group sono:

* Evitare la creazione di condizioni di competizione nell'applicazione dell'utente :  L'implementazione di un gruppo di eventi creerà una condizione di competizione nell'applicazione se: 

  * Non è chiaro chi sia responsabile della cancellazione di singoli bit (o flag). 
  * Non è chiaro quando un bit debba essere cancellato.
  * Non è chiaro se un bit era impostato o azzerato nel momento in cui un task è uscito dalla funzione API che ha testato il valore del bit (potrebbe  essere che un altro task o interrupt abbia modificato lo stato del bit).

  L'implementazione dei gruppi di eventi FreeRTOS rimuove il potenziale per le condizioni  di competizione includendo l'intelligenza incorporata per garantire che  l'impostazione, il test e la cancellazione dei bit appaia atomici. L'archiviazione locale dei thread e l'uso attento dei valori restituiti dalle funzioni API rendono possibile ciò.

* Evitare il non determinismo:  Il concetto di event groups implica un comportamento non deterministico perché non si sa quante attività sono bloccate su un event group e quindi non si sa quante condizioni dovranno essere  testate o quante task dovranno essere sbloccate quando viene impostato un bit di evento.

  Gli standard di qualità di FreeRTOS **non** consentono di eseguire azioni non deterministiche mentre gli interrupt sono disabilitati o dall'interno delle routine di servizio di interrupt. Per garantire che questi rigidi standard di qualità non vengano violati quando viene impostato un bit di evento:

  * Il meccanismo di blocco dell'utilità di pianificazione RTOS viene  utilizzato per garantire che gli interrupt rimangano abilitati quando un bit di evento viene impostato da un'attività RTOS. 
  * Il meccanismo centralizzato di interruzione differita viene utilizzato per differire l'azione di impostare un bit su un'attività quando si tenta  di impostare un bit di evento da una routine di servizio di  interruzione. 

  

  

  

   	

  

