# Queues 

Le code sono la forma principale di comunicazioni tra task. Possono essere utilizzati per inviare messaggi tra task e tra interrupt e task. Nella maggior parte dei casi vengono utilizzati come buffer FIFO (First In  First Out) thread-safe con i nuovi dati inviati in fondo alla coda,  sebbene i dati possano anche essere inviati in primo piano.

![](https://www.freertos.org/wp-content/uploads/2018/07/queue_animation.gif)

## Modello utente: massima semplicità, massima flessibilità. . .

Il modello di utilizzo della coda di FreeRTOS riesce a combinare  semplicità e flessibilità, attributi che normalmente si escludono a  vicenda. I messaggi  vengono inviati tramite le code per copia, il che significa che i dati  (che possono essere un puntatore a buffer più grandi) vengono copiati  nella coda anziché nella coda che archivia sempre solo un riferimento ai dati. Questo è l'approccio migliore perché:

1. I piccoli messaggi che sono già contenuti nelle variabili C (numeri  interi, piccole strutture, ecc.) Possono essere inviati direttamente in una coda. Non è necessario allocare un buffer per il messaggio e quindi copiare la variabile nel buffer allocato. Allo stesso modo, i messaggi possono essere letti dalle code direttamente nelle variabili C. Inoltre, l'invio a una coda in questo modo consente all'attività di  invio di sovrascrivere immediatamente la variabile o il buffer che è  stato inviato alla coda, anche quando il messaggio inviato rimane nella  coda. Poiché i dati contenuti nella variabile sono stati copiati nella coda, la variabile stessa è disponibile per il riutilizzo. Non è  necessario che l'attività che invia il messaggio e l'attività che riceve il messaggio concordino quale attività possiede il messaggio e quale  attività è responsabile della liberazione del messaggio quando non è più necessaria. 	
2. L'utilizzo di code che passano i dati per copia non impedisce che le  code vengano utilizzate per passare i dati per riferimento. Quando la dimensione di un messaggio raggiunge un punto in cui non è pratico  copiare l'intero messaggio nella coda byte per byte, definire la coda  per contenere i puntatori e copiare invece solo un puntatore al  messaggio nella coda. Questo è esattamente il modo in cui l' implementazione di [FreeRTOS + UDP] passa ampi buffer di rete attorno allo stack IP di FreeRTOS.
3. Il kernel si assume la completa responsabilità per l'allocazione della memoria utilizzata come area di archiviazione della coda.
4. È possibile inviare messaggi di dimensioni variabili definendo code per contenere strutture che contengono un membro che punta al messaggio in coda e un altro membro che contiene le dimensioni del messaggio in coda.
5. Una singola coda può essere utilizzata per ricevere diversi tipi di messaggi e da più posizioni, definendo la coda per contenere una struttura che ha un membro che contiene il tipo di messaggio e un altro membro che contiene i dati del messaggio (o un puntatore ai dati del messaggio). Il modo in cui i dati vengono interpretati dipende dal tipo di messaggio. Questo è esattamente il modo in cui l'attività che gestisce lo stack IP di FreeRTOS + UDP è in grado di utilizzare una singola coda per ricevere notifiche di eventi timer ARP, pacchetti ricevuti dall'hardware Ethernet, pacchetti ricevuti dall'applicazione, eventi di interruzione della rete, ecc.
6. Viene fornita un'API separata da utilizzare all'interno di un interrupt. Separare l'API utilizzata da una task RTOS da quella utilizzata da una routine di servizio di interrupt significa che l'implementazione delle funzioni API RTOS non comporta l'overhead di controllare il contesto della chiamata ogni volta che vengono eseguite. L'utilizzo di un'API di interrupt separata significa anche, nella maggior parte dei casi, la creazione di routine di servizio di interrupt compatibili con RTOS è più semplice per gli utenti finali rispetto a prodotti RTOS alternativi.
7. In ogni modo, l'API è più semplice.

## Blocking on Queues 

Quando una task tenta di leggere da una coda vuota, la task verrà posta nello stato Blocked (quindi non consuma tempo di CPU e possono essere eseguite altre task) finché i dati non diventano disponibili sulla coda o il tempo di blocco scade.

Quando una task tenta di scrivere su una coda piena, la task verrà posta nello stato Blocked (quindi non consuma tempo di CPU e possono essere eseguite altre attività) fino a quando uno spazio non diventa disponibile nella coda o il tempo di blocco scade.

Se è presente più di una task bloccata sulla stessa coda, la task con la priorità più alta sarà quella che viene sbloccata per prima

## Implementing

#### Create a Queue

```
QueueHandle_t xQueueCreate (UBaseType_t uxQueueLength, UBaseType_t uxItemSize);
```

Crea una nuova [coda](https://translate.googleusercontent.com/translate_c?depth=1&hl=it&pto=aue&rurl=translate.google.it&sl=auto&sp=nmt4&tl=it&u=https://www.freertos.org/Embedded-RTOS-Queues.html&usg=ALkJrhhS_gTocjxROUkucADQuxhF5DdxeQ) e restituisce un handle tramite il quale è possibile fare riferimento alla coda.

[configSUPPORT_DYNAMIC_ALLOCATION](https://translate.googleusercontent.com/translate_c?depth=1&hl=it&pto=aue&rurl=translate.google.it&sl=auto&sp=nmt4&tl=it&u=https://www.freertos.org/a00110.html&usg=ALkJrhhP7W3i1kUTikO9tnxk-2coudDhQg#configSUPPORT_DYNAMIC_ALLOCATION)  deve essere impostato su 1 in FreeRTOSConfig.h, o lasciato indefinito  (nel qual caso sarà impostato su 1 per impostazione predefinita),  affinché questa funzione API RTOS sia disponibile.

Ogni coda richiede RAM utilizzata per mantenere lo stato della coda e per  contenere gli elementi contenuti nella coda (l'area di archiviazione  della coda). Se una coda viene creata utilizzando xQueueCreate (), la RAM richiesta viene allocata automaticamente dall'heap FreeRTOS . Se una coda viene creata utilizzando xQueueCreateStatic() , la RAM viene fornita dal writer dell'applicazione, il che si traduce in  un numero maggiore di parametri, ma consente l'allocazione statica della RAM in fase di compilazione.

**Parametri:**

*uxQueueLength* :	Il numero massimo di elementi che la coda può contenere in qualsiasi momento. 			 	 	   *uxItemSize* : la dimensione, in byte, richiesta per contenere ogni elemento nella coda. Gli elementi vengono messi in    coda per copia, non per riferimento,  quindi questo è il numero di byte che verranno copiati per ogni elemento in coda. Ogni elemento nella coda deve avere le stesse dimensioni. 

**Ritorna:** se la coda viene creata correttamente, viene restituito un handle per la coda creata. Se non è stato possibile allocare la memoria richiesta per creare la coda, viene restituito NULL. 

```c
// Include queue support
#include <queue.h>

struct AMessage
{
    char ucMessageID;
    char ucData[ 20 ];
};

void vATask( void *pvParameters )
{
QueueHandle_t xQueue1, xQueue2;

    /* Create a queue capable of containing 10 unsigned long values. */
    xQueue1 = xQueueCreate( 10, sizeof( unsigned long ) );

    if( xQueue1 == NULL )
    {
        /* Queue was not created and must not be used. */
    }

    /* Create a queue capable of containing 10 pointers to AMessage
    structures.  These are to be queued by pointers as they are
    relatively large structures. */
    xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );

    if( xQueue2 == NULL )
    {
        /* Queue was not created and must not be used. */
    }

    /* ... Rest of task code. */
 }
```

