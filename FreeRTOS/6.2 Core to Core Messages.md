# Core To Core Messages

I buffer dei messaggi consentono il passaggio di messaggi discreti di  lunghezza variabile da una routine di servizio di interruzione a  un'attività o da un'attività a un'altra.

Ad esempio, i messaggi di lunghezza 10, 20 e 123 byte possono essere tutti scritti e letti dallo stesso buffer dei messaggi. A differenza di quando si utilizza un [buffer di flusso](https://translate.googleusercontent.com/translate_c?depth=1&hl=it&pto=aue&rurl=translate.google.it&sl=auto&sp=nmt4&tl=it&u=https://www.freertos.org/RTOS-stream-buffer-example.html&usg=ALkJrhhHf7KX4Y_tomBQt6eGLs--N1oUtw) , un messaggio a 10 byte può essere letto solo come messaggio a 10 byte, non come singoli byte.

## Dimensionamento di un buffer dei messaggi

Per consentire ai buffer dei messaggi di gestire messaggi di dimensioni  variabili, la lunghezza di ciascun messaggio viene scritta nel buffer  dei messaggi prima del messaggio stesso (ciò avviene internamente con le funzioni API di FreeRTOS).  La lunghezza è memorizzata in una variabile di tipo size_t, che in genere è di 4 byte su un'architettura a 32 byte. Pertanto, ad esempio, la scrittura di un messaggio da 10 byte in un buffer dei  messaggi consumerà effettivamente 14 byte di spazio nel buffer. Allo stesso modo, la scrittura di un messaggio da 100 byte in un buffer dei  messaggi memorizzerà effettivamente 104 byte di spazio nel buffer.

## Blocco di letture e scritture

**xMessageBufferReceive()** viene utilizzato per leggere i dati da un buffer dei messaggi da un'attività RTOS. **xMessageBufferReceiveFromISR()** viene utilizzato per leggere i dati da un buffer dei messaggi da una routine di servizio di interrupt (ISR). **xMessageBufferSend()** viene utilizzato per inviare dati a un buffer di messaggi da un'attività RTOS. **xMessageBufferSendFromISR()** viene utilizzato per inviare dati a un buffer dei messaggi da una routine di servizio di interrupt (ISR). Se viene specificato un tempo di blocco diverso da zero quando  un'attività utilizza xMessageBufferReceive () per leggere da un buffer  dei messaggi che risulta essere vuoto, l'attività verrà posta nello  stato Bloccato (quindi non consuma tempo della CPU e possono essere  eseguite altre attività) fino a quando i dati non diventano disponibili  nel buffer dei messaggi o il tempo di blocco scade. Se viene specificato un tempo di blocco diverso da zero quando  un'attività utilizza xMessageBufferSend () per scrivere su un buffer dei messaggi che risulta essere pieno, l'attività verrà posta nello stato  Blocked (quindi non consuma tempo della CPU e possono essere eseguite  altre attività) fino a quando uno spazio non diventa disponibile nel  buffer dei messaggi o il tempo di blocco non scade.

Poiché i buffer dei messaggi sono costruiti sui buffer del flusso, le macro  sbSEND_COMPLETE () e sbRECEIVE_COMPLETE () si comportano esattamente  come descritto per le ISR TO Task Streams